C51 COMPILER V9.00   19296P1                                                               07/07/2019 16:29:04 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE 19296P1
OBJECT MODULE PLACED IN ..\bin\19296p1.obj
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE ..\src\drv\19296p1.C LARGE BROWSE DEBUG OBJECTEXTEND PRINT(..\lst\19296p1.l
                    -st) OBJECT(..\bin\19296p1.obj)

line level    source

   1          /* 液晶模块型号：JLX19296-380
   2          并行接口
   3          驱动IC 是:ST75256
   4          改编：Bruce Dong
   5          2019.5.15
   6          */
   7          #include "../drv/STC8.H"
   8          #include "../drv/19296p1.H"
   9          //#include "../app/HMI.H"
  10          
  11          //Development Board Connection
  12          //sbit LCD19296_CS1 = P3^7; 
  13          //sbit LCD19296_RST = P3^6; 
  14          //sbit LCD19296_RS = P3^5; 
  15          //sbit LCD19296_RD = P3^4; 
  16          //sbit LCD19296_WR = P0^7; 
  17          
  18          //V1 temporary connection
  19          sbit LCD19296_IF0       = P4^1;
  20          sbit LCD19296_CS1 = P3^7; 
  21          sbit LCD19296_RST = P2^0; 
  22          sbit LCD19296_RS = P3^6; 
  23          sbit LCD19296_RD = P5^1; 
  24          sbit LCD19296_WR = P5^0; 
  25          
  26          //V2 connection
  27          //sbit LCD19296_CS1 = P4^1; 
  28          //sbit LCD19296_RST = P5^0; 
  29          //sbit LCD19296_RS = P3^7; 
  30          //sbit LCD19296_RD = P3^6; 
  31          //sbit LCD19296_WR = P5^1; 
  32          //另外P2.0~2.7 对应DB0~DB7*/
  33          //sbit key=P2^0; /*按键接口，P2.0 口与GND 之间接一个按键*/
  34          
  35          //extern uchar code Char1608_Up[], Char1608_Down[], Char1608_Left[], Char1608_Right[];
  36          //extern uchar code Hanzi1616_Up[], Hanzi1616_Down[], Hanzi1616_Left[], Hanzi1616_Right[];
  37          //
  38          //extern uchar code Hanzi_2424_XST_Dian[], Hanzi_2424_XST_Ji[],Hanzi_2424_XST_Fang[], Hanzi_2424_XST_Xiang
             -[];
  39          
  40          /*延时：1 毫秒的i 倍*/
  41          void delay(int i)
  42          {
  43   1              int j,k;
  44   1              for(j=0;j<i;j++)
  45   1              for(k=0;k<110;k++);
  46   1      }
  47          /*延时：1us 的i 倍*/
  48          void delay_us(int i)
  49          {
  50   1              int j,k;
  51   1              for(j=0;j<i;j++)
  52   1              for(k=0;k<1;k++);
  53   1      }
C51 COMPILER V9.00   19296P1                                                               07/07/2019 16:29:04 PAGE 2   

  54          
  55          //temporary send data function
  56          void LCD_Send_PData(uchar data2send)
  57          {
  58   1      //      uchar temp1;
  59   1      //      temp1 = data2send<<1;
  60   1      //      P2 = temp1;
  61   1              if((data2send&0x80)==0)
  62   1                      {P35 = 0;}              //D7
  63   1                      else
  64   1                              {P35 = 1;}
  65   1              if((data2send&0x40)==0)
  66   1                      {P27 = 0;}
  67   1                      else
  68   1                              {P27 = 1;}
  69   1              if((data2send&0x20)==0)
  70   1                      {P26 = 0;}
  71   1                      else
  72   1                              {P26 = 1;}
  73   1              if((data2send&0x10)==0)
  74   1                      {P25 = 0;}
  75   1                      else
  76   1                              {P25 = 1;}
  77   1              if((data2send&0x08)==0)
  78   1                      {P24 = 0;}
  79   1                      else
  80   1                              {P24 = 1;}
  81   1              if((data2send&0x04)==0)
  82   1                      {P23 = 0;}
  83   1                      else
  84   1                              {P23 = 1;}
  85   1              if((data2send&0x02)==0)
  86   1                      {P22 = 0;}
  87   1                      else
  88   1                              {P22 = 1;}
  89   1              if((data2send&0x01)==0)
  90   1                      {P21 = 0;}
  91   1                      else
  92   1                              {P21 = 1;}
  93   1      }
  94          
  95          
  96          
  97          
  98          //=============transfer command to LCM===============
  99          void SEND_CMD_LCD(uchar data1)
 100          {
 101   1              LCD19296_CS1=0;
 102   1              LCD19296_RS=0;
 103   1              
 104   1              LCD19296_RD=0;
 105   1              delay_us(1);
 106   1              LCD19296_WR=0;
 107   1      //      P2=data1;
 108   1              LCD_Send_PData(data1);
 109   1              LCD19296_RD=1;
 110   1              delay_us(1);
 111   1              LCD19296_CS1=1;
 112   1              LCD19296_RD=0;
 113   1      }
 114          
 115          //-----------transfer data to LCM---------------
C51 COMPILER V9.00   19296P1                                                               07/07/2019 16:29:04 PAGE 3   

 116          void SEND_DATA_LCD(uchar data1)
 117          {
 118   1              LCD19296_CS1=0;
 119   1              LCD19296_RS=1;
 120   1              LCD19296_RD=0;
 121   1              delay_us(1);
 122   1              LCD19296_WR=0;
 123   1      //      P2=data1;
 124   1              LCD_Send_PData(data1);
 125   1              LCD19296_RD=1;
 126   1              delay_us(1);
 127   1              LCD19296_CS1=1;
 128   1              LCD19296_RD=0;
 129   1      }
 130          
 131          void INIT_LCD()
 132          {
 133   1              LCD19296_IF0 = 0;
 134   1              LCD19296_RST=0;
 135   1              delay(100);
 136   1              LCD19296_RST=1;
 137   1              delay(100);
 138   1              SEND_CMD_LCD(0x30); //EXT=0
 139   1              SEND_CMD_LCD(0x94); //Sleep out
 140   1              SEND_CMD_LCD(0x31); //EXT=1
 141   1              SEND_CMD_LCD(0xD7); //Autoread disable
 142   1              SEND_DATA_LCD(0X9F); //
 143   1              SEND_CMD_LCD(0x32); //Analog SET
 144   1              SEND_DATA_LCD(0x00); //OSC Frequency adjustment
 145   1              SEND_DATA_LCD(0x01); //Frequency on booster capacitors->6KHz
 146   1              SEND_DATA_LCD(0x03); //Bias=1/11
 147   1              SEND_CMD_LCD(0x20); // Gray Level
 148   1              SEND_DATA_LCD(0x01);
 149   1              
 150   1              SEND_DATA_LCD(0x03);
 151   1              SEND_DATA_LCD(0x05);
 152   1              SEND_DATA_LCD(0x07);
 153   1              SEND_DATA_LCD(0x09);
 154   1              SEND_DATA_LCD(0x0b);
 155   1              SEND_DATA_LCD(0x0d);
 156   1              SEND_DATA_LCD(0x10);
 157   1              SEND_DATA_LCD(0x11);
 158   1              SEND_DATA_LCD(0x13);
 159   1              SEND_DATA_LCD(0x15);
 160   1              SEND_DATA_LCD(0x17);
 161   1              SEND_DATA_LCD(0x19);
 162   1              SEND_DATA_LCD(0x1b);
 163   1              SEND_DATA_LCD(0x1d);
 164   1              SEND_DATA_LCD(0x1f);
 165   1              SEND_CMD_LCD(0x30); //EXT=0
 166   1              SEND_CMD_LCD(0x75); //Page Address setting
 167   1              
 168   1              SEND_DATA_LCD(0X00); // XS=0
 169   1              SEND_DATA_LCD(0X14); // XE=159 0x28
 170   1              SEND_CMD_LCD(0x15); //Clumn Address setting
 171   1              SEND_DATA_LCD(0X00); // XS=0
 172   1              SEND_DATA_LCD(0Xff); // XE=256
 173   1              SEND_CMD_LCD(0xBC); //Data scan direction
 174   1              SEND_DATA_LCD(0x00); //MX.MY=Normal
 175   1              SEND_DATA_LCD(0xA6);
 176   1              SEND_CMD_LCD(0xCA); //Display Control
 177   1              SEND_DATA_LCD(0X00); //
C51 COMPILER V9.00   19296P1                                                               07/07/2019 16:29:04 PAGE 4   

 178   1              SEND_DATA_LCD(0X9F); //Duty=160
 179   1              SEND_DATA_LCD(0X20); //Nline=off
 180   1              SEND_CMD_LCD(0xF0); //Display Mode
 181   1              SEND_DATA_LCD(0X10); //10=Monochrome Mode,11=4Gray
 182   1              
 183   1              SEND_CMD_LCD(0x81); //EV control
 184   1      //      SEND_DATA_LCD(0x3a); //VPR[5-0]
 185   1              SEND_DATA_LCD(0x30); //VPR[5-0]
 186   1              SEND_DATA_LCD(0x03); //粗调对比度
 187   1              SEND_CMD_LCD(0x20); //Power control
 188   1              SEND_DATA_LCD(0x0B); //D0=regulator ; D1=follower ; D3=booste, on:1 off:0
 189   1              delay_us(100);
 190   1              SEND_CMD_LCD(0xAF); //Display on
 191   1      }
 192          
 193          /*写LCD 行列地址：X 为起始的列地址，Y 为起始的行地址，x_total,y_total 分别为列地址及行地址的起点到终点的差
             -值 */
 194          void lcd_address(uchar x,uchar y,x_total,y_total)
 195          {
 196   1              x=x-1;
 197   1              y=y+7;
 198   1              SEND_CMD_LCD(0x15); //Set Column Address
 199   1              SEND_DATA_LCD(x);
 200   1              SEND_DATA_LCD(x+x_total-1);
 201   1              SEND_CMD_LCD(0x75); //Set Page Address
 202   1              SEND_DATA_LCD(y);
 203   1              SEND_DATA_LCD(y+y_total-1);
 204   1              SEND_CMD_LCD(0x30);
 205   1              SEND_CMD_LCD(0x5c);
 206   1      }
 207          
 208          /*写LCD 行列地址：X 为起始的列地址，Y 为起始的行地址，x_total,y_total 分别为列地址及行地址的起点到终点的差
             -值 */
 209          void SET_LCD_DISP_AREA(uchar Column, uchar Page, Column_Total,Page_Total)
 210          {
 211   1              Column = Column - 1;
 212   1              Page = Page + 7;
 213   1              SEND_CMD_LCD(0x15); //Set Column Address
 214   1              SEND_DATA_LCD(Column);
 215   1              Column += Column_Total;
 216   1              Column -= 1;
 217   1              SEND_DATA_LCD(Column);
 218   1              SEND_CMD_LCD(0x75); //Set Page Address
 219   1              SEND_DATA_LCD(Page);
 220   1              Page += Page_Total;
 221   1              Page -= 1;
 222   1              SEND_DATA_LCD(Page);
 223   1              SEND_CMD_LCD(0x30);
 224   1              SEND_CMD_LCD(0x5c);
 225   1      }
 226          
 227          /*清屏*/
 228          void clear_screen(void)
 229          {
 230   1              uchar i,j;
 231   1              lcd_address(0,0,193,13);
 232   1              for(i=0;i<13;i++)
 233   1              {
 234   2                      for(j=0;j<193;j++)
 235   2                      {
 236   3                              SEND_DATA_LCD(0x00);
 237   3                      }
C51 COMPILER V9.00   19296P1                                                               07/07/2019 16:29:04 PAGE 5   

 238   2              }
 239   1      }
 240          
 241          void display_8x8(uchar column, uchar page,uchar *text) 
 242          { 
 243   1        uchar i; 
 244   1        lcd_address(column,page,8,1); 
 245   1          for(i=0;i<8;i++) 
 246   1          {
 247   2              SEND_DATA_LCD(*text);
 248   2              text++; 
 249   2          } 
 250   1      }
 251          
 252          void display_8x1(uchar column, uchar page,uchar text) 
 253          { 
 254   1        lcd_address(column,page,1,1); 
 255   1        SEND_DATA_LCD(text);
 256   1      }
 257          
 258          //void display_16x8(uchar column, uchar page,uchar *text) 
 259          //{ 
 260          //  uchar i; 
 261          //  lcd_address(column,page,8,2); 
 262          //    for(i=0;i<16;i++) 
 263          //    {
 264          //      SEND_DATA_LCD(*text);
 265          //      text++; 
 266          //    } 
 267          //}
 268          
 269          void CHAR_Display_16x8(uchar Column, uchar Page,uchar *dp, uchar Disp_Para) 
 270          { 
 271   1        uchar i, Char1608[16], *p1, *p2;
 272   1              SET_LCD_DISP_AREA(Column, Page, 8, 2); 
 273   1              
 274   1              p1 = Char1608;
 275   1              for(i=0;i<16;i++)
 276   1                      {*(p1+i) = *(dp+i);}
 277   1              
 278   1      //判断上横
 279   1              if((Disp_Para & Disp_UP)>0)
 280   1                      {
 281   2                                      p2 = Char1608_Up;
 282   2                                      for(i=0;i<16;i++)
 283   2                                      {*(p1+i)|=*(p2+i);}
 284   2                      }
 285   1                      else
 286   1                              {;}
 287   1      
 288   1      //判断下横
 289   1              if((Disp_Para & Disp_Down)>0)
 290   1                      {
 291   2                                      p2 = Char1608_Down;
 292   2                                      for(i=0;i<16;i++)
 293   2                                      {*(p1+i)|=*(p2+i);}
 294   2                      }
 295   1                      else
 296   1                              {;}
 297   1      
 298   1      //判断左竖
 299   1              if((Disp_Para & Disp_Left)>0)
C51 COMPILER V9.00   19296P1                                                               07/07/2019 16:29:04 PAGE 6   

 300   1                      {
 301   2                                      p2 = Char1608_Left;
 302   2                                      for(i=0;i<16;i++)
 303   2                                      {*(p1+i)|=*(p2+i);}
 304   2                      }
 305   1                      else
 306   1                              {;}
 307   1      
 308   1      //判断右竖
 309   1              if((Disp_Para & Disp_Right)>0)
 310   1                      {
 311   2                                      p2 = Char1608_Right;
 312   2                                      for(i=0;i<16;i++)
 313   2                                      {*(p1+i)|=*(p2+i);}
 314   2                      }
 315   1                      else
 316   1                              {;}
 317   1      
 318   1          for(i=0;i<16;i++) 
 319   1          {
 320   2              SEND_DATA_LCD(*(p1+i));
 321   2          } 
 322   1      }
 323          
 324          ///*显示16*16 点阵的汉字或等同于16*16 点阵的图像*/
 325          //void disp_16x16(uchar x,uchar y,uchar *dp)
 326          //{
 327          //      uchar i,j;
 328          //      lcd_address(x,y,16,2);
 329          //      for(i=0;i<2;i++)
 330          //      {
 331          //              for(j=0;j<16;j++)
 332          //              {
 333          //                      SEND_DATA_LCD(*dp);
 334          //                      dp++;
 335          //              }
 336          //      }
 337          //}
 338          
 339          /*显示16*16 点阵的汉字*/
 340          /*形参说明：bit0：上横线，bit1：下横线，bit2：左竖线，bit3：右竖线，bit4：光标，bit5：反显*/
 341          /*      bit  7 6 5 4 3 2 1 0    */
 342          /*      Para x x x x x x x x    */
 343          
 344          void Hanzi_Disp_16x16(uchar Column, uchar Page, uchar *dp, uchar Disp_Para)
 345          {
 346   1              uchar i, Hanzi1616[32], *p1, *p2;
 347   1              SET_LCD_DISP_AREA(Column, Page, 16, 2);
 348   1      
 349   1              p1 = Hanzi1616;
 350   1              for(i=0;i<32;i++)
 351   1                      {*(p1+i) = *(dp+i);}
 352   1              
 353   1      //判断上横
 354   1              if((Disp_Para & Disp_UP)>0)
 355   1                      {
 356   2                                      p2 = Hanzi1616_Up;
 357   2                                      for(i=0;i<32;i++)
 358   2                                      {*(p1+i)|=*(p2+i);}
 359   2                      }
 360   1                      else
 361   1                              {;}
C51 COMPILER V9.00   19296P1                                                               07/07/2019 16:29:04 PAGE 7   

 362   1      
 363   1      //判断下横
 364   1              if((Disp_Para & Disp_Down)>0)
 365   1                      {
 366   2                                      p2 = Hanzi1616_Down;
 367   2                                      for(i=0;i<32;i++)
 368   2                                      {*(p1+i)|=*(p2+i);}
 369   2                      }
 370   1                      else
 371   1                              {;}
 372   1      
 373   1      //判断左竖
 374   1              if((Disp_Para & Disp_Left)>0)
 375   1                      {
 376   2                                      p2 = Hanzi1616_Left;
 377   2                                      for(i=0;i<32;i++)
 378   2                                      {*(p1+i)|=*(p2+i);}
 379   2                      }
 380   1                      else
 381   1                              {;}
 382   1      
 383   1      //判断右竖
 384   1              if((Disp_Para & Disp_Right)>0)
 385   1                      {
 386   2                                      p2 = Hanzi1616_Right;
 387   2                                      for(i=0;i<32;i++)
 388   2                                      {*(p1+i)|=*(p2+i);}
 389   2                      }
 390   1                      else
 391   1                              {;}
 392   1      
 393   1      //最终显示
 394   1              for(i=0;i<32;i++)
 395   1              {
 396   2                      SEND_DATA_LCD(*(p1+i));
 397   2              }
 398   1      }
 399          
 400          /*显示24*24 点阵的汉字或等同于24*24 点阵的图像*/
 401          void disp_24x24(int x,int y,uchar *dp)
 402          {
 403   1              uchar i;
 404   1              lcd_address(x,y,24,3);
 405   1              for(i=0;i<72;i++)
 406   1              {
 407   2                      SEND_DATA_LCD(*(dp+i));
 408   2              }
 409   1      }
 410          
 411          /////*显示32*32 点阵的汉字或等同于32*32 点阵的图像*/
 412          ////void disp_32x32(int x,int y,uchar *dp)
 413          ////{
 414          ////    uchar i,j;
 415          ////    lcd_address(x,y,32,4);
 416          ////    for(i=0;i<4;i++)
 417          ////    {
 418          ////            for(j=0;j<32;j++)
 419          ////            {
 420          ////                    SEND_DATA_LCD(*dp);
 421          ////                    dp++;
 422          ////            }
 423          ////    }
C51 COMPILER V9.00   19296P1                                                               07/07/2019 16:29:04 PAGE 8   

 424          ////}
 425          ////
 426          /////*显示48*48 点阵的汉字或图像*/
 427          ////void disp_48x48(uchar x,uchar y,char *dp)
 428          ////{
 429          ////    uchar i,j;
 430          ////    lcd_address(x,y,48,6);
 431          ////    for(i=0;i<6;i++)
 432          ////    {
 433          ////            for(j=0;j<48;j++)
 434          ////            {
 435          ////                    SEND_DATA_LCD(*dp);
 436          ////                    dp++;
 437          ////            }
 438          ////    }
 439          ////}
 440          ////
 441          /////*显示64*48 点阵的汉字或图像*/
 442          ////void disp_64x48(uchar x,uchar y,char *dp)
 443          ////{
 444          ////    uchar i,j;
 445          ////    lcd_address(x,y,55,6);
 446          ////    for(i=0;i<6;i++)
 447          ////    {
 448          ////            for(j=0;j<55;j++)
 449          ////            {
 450          ////                    SEND_DATA_LCD(*dp);
 451          ////                    dp++;
 452          ////            }
 453          ////    }
 454          ////}
 455          ////
 456          /////*显示96*24 点阵的图像*/
 457          ////void disp_96x24(uchar x,uchar y,char *dp)
 458          ////{
 459          ////    uchar i,j; 
 460          ////    lcd_address(x,y,96,3);
 461          ////    for(i=0;i<3;i++)
 462          ////    {
 463          ////            for(j=0;j<96;j++)
 464          ////            {
 465          ////                    SEND_DATA_LCD(*dp);
 466          ////                    dp++;
 467          ////            }
 468          ////    }
 469          ////}
 470          ////
 471          /////*显示196*96 点阵的图像*/
 472          ////void disp_192x96(uchar x,uchar y,char *dp)
 473          ////{
 474          ////    uchar i,j; 
 475          ////    lcd_address(x,y,192,12);
 476          ////    for(i=0;i<12;i++)
 477          ////    {
 478          ////            for(j=0;j<192;j++)
 479          ////            {
 480          ////                    SEND_DATA_LCD(*dp);
 481          ////                    dp++;
 482          ////            }
 483          ////    }
 484          ////}
 485          
C51 COMPILER V9.00   19296P1                                                               07/07/2019 16:29:04 PAGE 9   

 486          //特殊符号（取字模方式：阴码，列行式，顺向
 487          
 488          uchar code Char0808_Up[]={0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80};/*"上横"*/
 489          
 490          uchar code Char0808_Down[]={0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01};/*"下横"*/
 491          
 492          uchar code Char0808_Left[]={0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00};/*"左竖"*/
 493          
 494          uchar code Char0808_Right[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF};/*"右竖"*/
 495          
 496          uchar code Char0808_UpDown[]={0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81};/*"上横+下横"*/
 497          
 498          uchar code Char1608_Up[]={
 499          0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};/*"上横"*/
 500          
 501          uchar code Char1608_Down[]={
 502          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01};/*"下横"*/
 503          
 504          uchar code Char1608_Left[]={
 505          0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00};/*"左竖"*/
 506          
 507          uchar code Char1608_Right[]={
 508          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF};/*"右竖"*/
 509          
 510          uchar code Hanzi1616_Up[]={
 511          0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
 512          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};/*"上横"*/
 513          
 514          uchar code Hanzi1616_Down[]={
 515          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 516          0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01};/*"下横"*/
 517          
 518          uchar code Hanzi1616_Left[]={
 519          0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 520          0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};/*"左竖"*/
 521          
 522          uchar code Hanzi1616_Right[]={
 523          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
 524          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF};/*"右竖"*/
 525          
 526          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1948    ----
   CONSTANT SIZE    =    232    ----
   XDATA SIZE       =   ----      97
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
