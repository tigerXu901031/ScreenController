C51 COMPILER V9.00   FIFO                                                                  06/12/2019 17:22:59 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE FIFO
OBJECT MODULE PLACED IN ..\bin\fifo.obj
COMPILER INVOKED BY: C:\Program Files\Keil\C51\BIN\C51.EXE ..\src\srv\fifo.c BROWSE DEBUG OBJECTEXTEND PRINT(.\fifo.lst)
                    - OBJECT(..\bin\fifo.obj)

line level    source

   1          /* 
   2             -----------------------------------------------------------------------
   3             Author   - Tiger.Xu
   4             Date     - 2019.06.08
   5             Version  - 0.0.1
   6          
   7             Change Notes:
   8                  2019.06.08      Tiger.Xu
   9                  Initial version
  10          
  11                  ...             ...
  12                  ...
  13              
  14             Description:
  15                  Generic FIFO(First In First Out) library
  16             -----------------------------------------------------------------------
  17          */
  18          #include "fifo.h"
  19          
  20          fifo_type fifoInit(unsigned int unitLen)
  21          {
  22   1          fifo_type fifoObj;
  23   1          fifoObj.unitLen = unitLen;
  24   1          fifoObj.curPtr = 0;
  25   1      
  26   1          return fifoObj;
  27   1      }
*** ERROR C241 IN LINE 27 OF ..\SRC\SRV\FIFO.C: '_fifoInit': auto segment too large
  28          
  29          fifoSts_type getFifoData(fifo_type *fifoObj, void *newData)
  30          {
  31   1          fifoSts_type returnVal = readFail;
  32   1          
  33   1          newData = (unsigned int)newData;
  34   1      
  35   1          unsigned int emptyData[fifoObj->unitLen];
*** ERROR C141 IN LINE 35 OF ..\SRC\SRV\FIFO.C: syntax error near 'unsigned'
*** ERROR C202 IN LINE 35 OF ..\SRC\SRV\FIFO.C: 'emptyData': undefined identifier
  36   1          
  37   1          /* If the current data pointer is higher than 0
  38   1             it means there has valid data to output */
  39   1          if(fifoObj->curPtr > 0)
  40   1          {
  41   2              /* Output the first item in FIFO */
  42   2              memcpy(newData, &fifoObj->fifoData[0], fifoObj->unitLen);
  43   2              
  44   2              /* Clear the first item content */
  45   2              memcpy(&fifoObj->fifoData[0], &emptyData, fifoObj->unitLen);
  46   2      
  47   2              /* Move all the existing items to the one position forward */
  48   2              memcpy(&fifoObj->fifoData[0], &fifoObj->fifoData[1],fifoObj->curPtr - 1);
  49   2      
  50   2              /* Clear the last valid item content */
  51   2              memcpy(&fifoObj->fifoData[fifoObj->curPtr], &emptyData, fifoObj->unitLen);
C51 COMPILER V9.00   FIFO                                                                  06/12/2019 17:22:59 PAGE 2   

  52   2      
  53   2              /* Move the current pointer of the FIFO */
  54   2              fifoObj->curPtr --;
  55   2      
  56   2              returnVal = readSuccess;
  57   2          }
  58   1          /* If the FIFO is empty then return all zero and
  59   1          with the readFail state */
  60   1          else{
  61   2              memcpy(newData, &emptyData, fifoObj->unitLen);
  62   2              returnVal = readFail;
  63   2          }
  64   1          return returnVal;
  65   1      }
  66          
  67          fifoSts_type setFifoData(fifo_type *fifoObj, void *newData)
  68          {
  69   1          fifoSts_type returnVal = writeFail;
  70   1      
  71   1          newData = (unsigned int)newData;
  72   1      
  73   1          /* Check whether the FIFO has the spare space to write 
  74   1             into the new data */
  75   1          if((FIFO_MAX_LENGTH - (fifoObj->unitLen * fifoObj->curPtr)) >= fifoObj->unitLen)
  76   1          {
  77   2              memcpy(&fifoObj->fifoData[fifoObj->curPtr], newData, fifoObj->unitLen);
  78   2              fifoObj->curPtr ++;
  79   2              returnVal = writeSuccess;
  80   2          }
  81   1          /* The FIFO is full no space to write then return fail */
  82   1          else
  83   1          {
  84   2              returnVal = readFail;
  85   2          }
  86   1          return returnVal;
  87   1      }

C51 COMPILATION COMPLETE.  0 WARNING(S),  3 ERROR(S)
